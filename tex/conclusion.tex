\section{Conclusion and Future Work}

Completing this thesis, the following sections outline the results and provide opportunities on how to continue this work in the future.

\subsection{Conclusion}

It has been pointed out, how the increasing complexity of designs can be handled using the Universal Verification Methodology in collaboration with Metric
Driven Verification by creating a testbench for the microcode engine.\\
By analyzing the engine, it was shown, which areas of the design had to be checked or covered, to ensure, that its behavior is always according to its
specifications.
Thereby, it was displayed, that a simple black box verification of the DUT, would not provide enough information about the internal state of the microcode
engine. Therefore, additional data was collected from the internal components of the design.\\
Multiple tests were created to generate stimuli, reaching all interesting areas of the DUT.
Their stimuli were applied to the different interfaces of the design using the sequence drivers of the individual agents within the testbench.
The separate sequence drivers were thereby controlled by a virtual sequence driver, as a result of that directing the execution of the tests.\\
A complex reference model was implemented, using a list of active instructions to be able to consider all conflicts, that can occur, when the engine was
executing the following instructions, while accesses on the CSR were still pending. Together with that, a stall barrier was used to ensure, that no following
instructions would access the critical register of the scratchpad or pass a previous instruction until the conflict was solved by the completion of the pending
CSR access. \\
The scoreboard of the module UVC used both, the collected data from the DUT and the predicted ones from the reference model, to create a
self-checking verification environment.
The coverage collected from the interfaces of the microcode engine as well as the active instructions of the reference model ensured, that all interesting
scenarios of the behavior of the design were examined. Thereby giving confidence in the effectiveness of the functional verification of the microcode engine.


\subsection{Future Work}

Although the microcode engine was functionally verified, the confidence in the correct behavior of the design could be increased by using formal verification
capabilities. Using them, it could be formal proven, that the behavior of the engine is always correct according to the specification. \\
Additionally a generator could be implemented, that converts assembler code into tests, that can be used within the testbench.
So when the assembler code shows undesired behavior within the microcode engine, the advanced debugging capabilities of the testbench could be used to identify
the bug.
